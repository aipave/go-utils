package test_example

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/aipave/go-utils/algorithms"
	"github.com/aipave/go-utils/dbms/gredis"
	"github.com/aipave/go-utils/gcache"
	"github.com/aipave/go-utils/gcast"
	"github.com/aipave/go-utils/gexit"
	"github.com/aipave/go-utils/ginfos"
	"github.com/aipave/go-utils/gtime"
	"github.com/go-redis/redis/v8"
	"github.com/sirupsen/logrus"

	"gopkg.in/yaml.v3"
)

var redisConfigFile = flag.String("f", "config.yaml", "the config file for dbms test")

func GetRedisConfig() RedisConfig {
	return redisConfig
}

var redisConfig RedisConfig

type RedisConfig struct {
	RWRedis gredis.RedisConfig `yaml:"RWRedis"`
	RRedis  gredis.RedisConfig `yaml:"RRedis"`
}

func init() {
	//ginfos.Version()

	data, err := ioutil.ReadFile(*redisConfigFile)
	if err != nil {
		logrus.Errorf("open file err %v", err)
	}
	err = yaml.Unmarshal(data, &redisConfig)
	if err != nil {
		logrus.Errorf("unmarshal file err|%v", err)
	}

	InitRedisClient()

}

var rRedisClient *redis.Client
var rwRedisClient *redis.Client
var testDistributeLock = redis.NewScript(`
---
--- Generated by ByteMagic-Lyu
--- DateTime: 2022/10/3 16:48
---

--local lock = KEYS[1]
--local ip   = ARGV[1]
--local ttl  = ARGV[2] + 0

local ip = redis.call('GET', KEYS[1])
-- no instance running now
if ip == false then
    local result = redis.call('SET', KEYS[1],  ARGV[1], 'NX', 'EX', ARGV[2]) -- lock grab
    if result ~= false and result.ok == 'OK' then
        return 1 -- lock grab success
    end

-- has instance running now
else if ip ~= false and ip == ARGV[1] then
    redis.call('EXPIRE', KEYS[1], ARGV[2]) -- lock grab，renewal
    return 2 -- renewal success
end
end

return 0 -- fail to grab lock
`)
var testGrabEnvelopScript = redis.NewScript(`
-- Parameters: KEYS[1]-the envelope list, KEYS[2]-the list of user and envelope consumption, KEYS[3]-the hash object used for deduplication, KEYS[4]-the user ID.
-- Function: tries to get an envelope, returns a JSON string if successful, or nil if not.
-- Return value: nil or a JSON string, {"uid":"user ID","id":"envelope ID"}.
-- If the user has already grabbed an envelope, returns nil.

-- Step 1: Check for duplicate participation.(only for 1 times)
-- if redis.call('hexists', KEYS[3], KEYS[4]) == 1 then --  > hexists grab_times 666888
--  return nil

-- Or Method1.Step 1: Check for duplicate participation.(only for n times)
-- if redis.call('hget', KEYS[3], KEYS[4]) and redis.call('hincrby', KEYS[3], KEYS[4], 1) >= 4 then -- 3 times
--	return nil

-- Or Method2.Step 1: Check for duplicate participation.(only for n times)
local count = redis.call('hget', KEYS[3], KEYS[4])
if count and tonumber(count) >= 3 then 
	return nil
else
  -- Step 2: Get an envelope.
  local luckMoney = redis.call('rpop', KEYS[1]); -- > rpop envelope
  if luckMoney then
    local data = cjson.decode(luckMoney);
    data['uid'] = KEYS[4]; -- add user info
    local re = cjson.encode(data);
	-- Add the user ID to the hash for deduplication, with a value of 1.
    redis.call('hincrby', KEYS[3], KEYS[4], 1); -- > hset grab_times 666888 1, if use Method1, this not need
	-- Step 3: Add the user and envelope to the consumption list.
    redis.call('lpush', KEYS[2], re); -- > lpush already_grab {id:xx,uid:xx}
    return re;
  end
end
return nil
`)
var testMvccScript = redis.NewScript(`
-- the technique of using a version number to track changes to a database record is a form of multi-version concurrency control (MVCC).
-- Here's an example in mysql:
-- CREATE TABLE users (
--   id SERIAL PRIMARY KEY,
--   name TEXT NOT NULL,
--   email TEXT NOT NULL,
--   password TEXT NOT NULL,
--   version INT NOT NULL
-- );
-- Step1.Retrieve the current version number of the user record
-- SELECT version FROM users WHERE id = 1; // -- Suppose the current version number is curVersion(3)
-- Step2.Update the user record with new information 
-- UPDATE users SET name = 'Alice', email = 'alice@example.com', version = curVersion + 1 WHERE id = 1 AND version = curVersion;
-- If the version number in the database matches the version number you have, the record will be updated 
-- and the new version number (4) will be stored. Otherwise, 
-- the update will not be performed and no changes will be made to the database.

local seat_info_field = ARGV[1]
local version = tonumber(ARGV[2])
local new_seat_info = ARGV[3]

local cur_version
local cur_seat_info = redis.call("HGET", KEYS[1], seat_info_field)
if cur_seat_info == false then	 -- no seat info
	cur_version = 0
else 									
	local tmp = cjson.decode(cur_seat_info)
	if tmp["version"] == nil then  -- seat info exist->no version num
		cur_version = 0
	else 						-- seat info exist->has version num
		cur_version = tmp["version"]
	end
end

if cur_version == version then -- same version num, update
	local new_info_tmp = cjson.decode(new_seat_info)
	new_info_tmp["version"] = cur_version + 1 -- update the version

    local new_info_update = cjson.encode(new_info_tmp);
	redis.call("hset", KEYS[1], seat_info_field, new_info_update)
	return 1
else 
	return 0
end
`)

var Redis redisMgr

type redisMgr struct {
}

var LuaScriptMgr LuaScripts

type LuaScripts struct {
	LuaSha1HashGrabEnvelope  string
	LuaSha1HashChangeSeatNum string
}

func InitRedisClient() {
	rRedisClient = gredis.NewRedisClient(
		gredis.WithAddr(GetRedisConfig().RRedis.Addr),
		gredis.WithPassword(GetRedisConfig().RRedis.Password),
		gredis.WithPoolSize(GetRedisConfig().RRedis.PoolSize),
		gredis.WithReadTimeOut(time.Duration(GetRedisConfig().RRedis.ReadTimeout)*time.Millisecond),
		gredis.WithWriteTimeOut(time.Duration(GetRedisConfig().RRedis.WriteTimeout)*time.Millisecond),
	)

	rwRedisClient = gredis.NewRedisClient(
		gredis.WithAddr(GetRedisConfig().RWRedis.Addr),
		//gredis.WithPassword(GetRedisConfig().RWRedis.Password),
		gredis.WithPoolSize(GetRedisConfig().RWRedis.PoolSize),
		gredis.WithReadTimeOut(time.Duration(GetRedisConfig().RWRedis.ReadTimeout)*time.Millisecond),
		gredis.WithWriteTimeOut(time.Duration(GetRedisConfig().RWRedis.WriteTimeout)*time.Millisecond),
	)

	var err error
	LuaScriptMgr.LuaSha1HashChangeSeatNum, err = testMvccScript.Load(context.Background(), rwRedisClient).Result()
	if err != nil || len(LuaScriptMgr.LuaSha1HashChangeSeatNum) == 0 {
		logrus.Fatalf("load redis lua script err:%v", err)
		return
	}
	logrus.Infof("load redis lua script success:%v", LuaScriptMgr.LuaSha1HashChangeSeatNum)

	// When you load a Lua script using the Load method of the Script struct,
	// Redis will compile the script and calculate its SHA1 hash.
	// The hash variable in your code contains this calculated SHA1 hash value.
	// You can use this hash value to execute the loaded script in Redis by calling the EvalSha method of the Redis client,
	// passing in the hash value as the first argument.
	LuaScriptMgr.LuaSha1HashGrabEnvelope, err = testGrabEnvelopScript.Load(context.Background(), rwRedisClient).Result()
	if err != nil || len(LuaScriptMgr.LuaSha1HashGrabEnvelope) == 0 {
		logrus.Fatalf("load redis lua script err:%v", err)
		return
	}
	logrus.Infof("load redis lua script success:%v", LuaScriptMgr.LuaSha1HashGrabEnvelope)

}

// /> redis keys
type keyBuilder int

var Keys keyBuilder

func (keyBuilder) Ludo2MatchPool() string {
	return fmt.Sprintf("ludo2_match_pool")
}
func (keyBuilder) Ludo2UserLastMatchEnd(strUid string) string {
	return fmt.Sprintf("ludo2_last_match_end:%s", strUid)
}

// /> redis opts
func (r *redisMgr) ScanLudoMatchPool(cursor uint64, count int64) (vStr []string, cursorRet uint64, err error) {
	redisKey := Keys.Ludo2MatchPool()
	vStr, cursorRet, err = rRedisClient.SScan(context.Background(), redisKey, cursor, "", count).Result()
	if err == redis.Nil {
		return
	}
	if err != nil {
		logrus.Errorf("%s|err:%v, key:%s", ginfos.FuncName(), err, redisKey)
		return
	}
	return
}

const GlobalRedisScanCount int64 = 200

func (r *redisMgr) GetLudoMatchPool() (players []string, err error) {
	var cursor uint64 = 0
	var tmpPlayers []string
	tmpPlayers, cursor, err = r.ScanLudoMatchPool(cursor, GlobalRedisScanCount)
	players = append(players, tmpPlayers...)
	for 0 != cursor {
		tmpPlayers, cursor, err = r.ScanLudoMatchPool(cursor, GlobalRedisScanCount)
		players = append(players, tmpPlayers...)
	}
	return
}

func (r *redisMgr) IsPkMatchPoolUser(strUid string) bool {
	redisKey := Keys.Ludo2MatchPool()
	redisKeyVal, ok := gcache.Get(redisKey)
	if ok {
		if val, ok := redisKeyVal.(bool); ok {
			logrus.Infof("get from cache ok, %v", val)
			return val
		} else {
			logrus.Errorf("parse redis val fail|%v", redisKeyVal)
		}
	}
	res, err := rRedisClient.SIsMember(context.Background(), redisKey, strUid).Result()
	if err == redis.Nil {
		return false
	}
	if err != nil {
		logrus.Errorf("%v|key:%v", ginfos.FuncName(), redisKey)
	}
	gcache.Set(redisKey, gcast.ToBool(res), 3)
	logrus.Infof("get from redis ok, %v", res)
	return err == nil && gcast.ToInt32(res) == 1

}

func Sadd(strUid string) bool {
	redisKey := Keys.Ludo2MatchPool()
	err := rwRedisClient.SAdd(context.Background(), redisKey, strUid).Err()
	if err != nil {
		logrus.Errorf("sadd %v %v err", redisKey, strUid)
		return false
	}
	return true

}

func (r *redisMgr) Zrange(strUid string) (int64, map[string]map[string]bool) {
	var lastEndTime int64 = 0
	recentMatchUsersMap := make(map[string]map[string]bool)
	redisKey := Keys.Ludo2UserLastMatchEnd(strUid)
	op := redis.ZRangeBy{
		Min:    gcast.ToString(time.Now().Unix() - gtime.IMinute*30), // min score
		Max:    "+inf",                                               // max score
		Offset: 0,                                                    // same as mysql limit
		Count:  60,                                                   // data count for one time
	}
	vals, err := rRedisClient.ZRevRangeByScoreWithScores(context.Background(), redisKey, &op).Result()
	if err == redis.Nil {
		return lastEndTime, recentMatchUsersMap
	}
	if err != nil {
		logrus.Errorf("%v|err:%v, key:%s", ginfos.FuncName(), err, redisKey)
		return lastEndTime, recentMatchUsersMap
	}

	for index, val := range vals {
		if index == 0 {
			lastEndTime = gcast.ToInt64(val.Score)
		}

		matchUidStr := val.Member.(string)

		if recentMatchUsersMap[strUid] == nil {
			recentMatchUsersMap[strUid] = make(map[string]bool)
		}

		recentMatchUsersMap[strUid][matchUidStr] = true

	}
	logrus.Infof("%v, %v", lastEndTime, recentMatchUsersMap)
	return lastEndTime, recentMatchUsersMap
}

func TestRedis(t *testing.T) {
	t.Log(GetRedisConfig())

	///> test1--> Redis set, sadd, srem
	matchPlayers, _ := Redis.GetLudoMatchPool()
	for _, strUid := range matchPlayers {
		ctx, cancel := context.WithCancel(context.Background())
		go func(ctx context.Context, strUid string) {
			curTimer := time.NewTicker(1 * time.Second)
		Loop:
			for {
				select {
				case <-ctx.Done():
					break Loop
				case <-curTimer.C:
					// do some logic
					logrus.Infof("match user info|%v", strUid)
					break Loop
				}
			}
		}(ctx, strUid)
		gexit.Close(cancel)
	}

	// test2-->
	ctx, cancel := context.WithCancel(context.Background())
	go func(ctx context.Context) {
		curTimer := time.NewTicker(1 * time.Second)
	Loop:
		for {
			select {
			case <-ctx.Done():
				break Loop
			case <-curTimer.C:
				Redis.IsPkMatchPoolUser("666888")
				// zadd ludo2_last_match_end:112344 1666687555  123456
				Redis.Zrange("666888")

			}
		}
	}(ctx)
	gexit.Close(cancel)

	gexit.Wait()
}

func RandPool() {
	Sadd(gcast.ToString(100000 + rand.Int63()%900000))
}

func TestRedisTimer(t *testing.T) {
	var timer = gredis.NewCron(rwRedisClient, ginfos.FuncName(), 10) // cause judge by ip, so need to test in diff ip
	_ = timer.AddFunc("*/1 * * * * *", RandPool)
	timer.Start()
	gexit.Wait()

}

func TestRedisScript(t *testing.T) {
	roomid := 981907981907981907
	key := fmt.Sprintf("player:%v", roomid)
	res, err := testMvccScript.Run(context.Background(), rRedisClient, []string{key}, "8", 2, "test").Bool()
	if err != nil {
		logrus.WithContext(context.Background()).Errorf("update error")
		return
	}
	if !res {
		logrus.WithContext(context.Background()).Infof("update confict")
		return
	}
	logrus.WithContext(context.Background()).Infof("update success")
	return
}

type EnvelopeInfo struct {
	Id     int64  `json:"id"`
	Amount string `json:"amount"` // use string to store %.2f float
	Uid    int64  `json:"uid"`
}

// need coustom unmarshalJSON cause the uid is int64 type instead of string type
func (e *EnvelopeInfo) UnmarshalJSON(data []byte) error {
	type Alias EnvelopeInfo ///< Define an alias for the EnvelopeInfo struct to make it easier to reference later.
	tmp := &struct {        ///< Create a temporary struct that includes the Alias alias and an additional field called UidStr.
		*Alias
		UidStr string `json:"uid"`
	}{
		Alias: (*Alias)(e),
	}
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	e.Uid = gcast.ToInt64(tmp.UidStr)

	return nil
}

func CreateEnvelope(amount float64, count int64) (string, bool) {
	amounts := allocateEnvelope(100, 30)
	envelopeKey := fmt.Sprintf("envelope:%v", algorithms.Snowflake.NextOptStreamID())

	var jsEnvelopeInfos []string
	for id, amount := range amounts {
		envelopeInfo := &EnvelopeInfo{
			Id:     gcast.ToInt64(id + 1),
			Amount: fmt.Sprintf("%.2f", amount),
		}
		jsEnveInfo, _ := json.Marshal(envelopeInfo)
		jsEnvelopeInfos = append(jsEnvelopeInfos, string(jsEnveInfo))

	}

	// use []string to batch rpush
	err := rwRedisClient.RPush(context.Background(), envelopeKey, jsEnvelopeInfos).Err()
	if err != nil {
		return "", false
	}

	return envelopeKey, true

}

// allocate envelope
func allocateEnvelope(totalAmount float64, num int) []float64 {
	// Initialize random number generator
	rand.Seed(time.Now().UnixNano())

	// Store the amount of each envelope
	amounts := make([]float64, num)

	// Remaining amount
	restAmount := totalAmount

	// Remaining number of envelopes
	restNum := num

	for i := 0; i < num; i++ {
		if restNum == 1 {
			// Directly allocate the remaining amount for the last envelope
			amounts[i] = restAmount
		} else {
			// Generate a random amount for the current envelope
			coefficient := rand.Float64() // rand in 0 < xx < 1
			if i%2 == 0 {
				coefficient += rand.Float64()
			}
			randAmount := coefficient * restAmount / float64(restNum)
			amounts[i] = randAmount

			// Update the remaining amount and number of envelopes
			restAmount -= randAmount
			restNum--
		}
	}

	///> can delete this
	//sum := 0.0
	//for _, amount := range amounts {
	//	sum += amount
	//}
	//if sum != totalAmount {
	//	// Adjust the amount of the last envelope
	//	amounts[num-1] += totalAmount - sum
	//}

	return amounts
}

func TestRandEnvelope(t *testing.T) {
	totalAmount := 100.0 // 总金额
	num := 50            // 红包个数

	// 分配红包
	amounts := allocateEnvelope(totalAmount, num)

	// 打印每个红包的金额
	var count float64 = 0
	for i, amount := range amounts {
		fmt.Printf("红包%d：%.2f元\n", i+1, amount)
		count += amount
	}
	fmt.Printf("count:%.2f", count)
}
func TestNewEnv(t *testing.T) {
	envelopeKey, ok := CreateEnvelope(100, 10)
	logrus.Infof("key=%v, ok=%v", envelopeKey, ok)

}

func TestGrabEnvelopeDemo(t *testing.T) {
	envelopeKey := "envelope:1633685538140921856"
	//result, err := rwRedisClient.Eval(context.Background(), LuaScriptMgr.LuaSha1HashGrabEnvelope,
	result, err := testGrabEnvelopScript.Run(context.Background(), rwRedisClient,
		[]string{
			envelopeKey,
			fmt.Sprintf("%v:consumption_list", envelopeKey),
			fmt.Sprintf("%v:dedup_hash", envelopeKey),
			"666888",
		}).Result()
	if err == redis.Nil {
		logrus.Warning("User has already grabbed an envelope, or there are no envelopes left.\n")
		return
	}
	if err != nil {
		logrus.Errorf("grab error:%v", err)
		return
	}
	grabInfo := EnvelopeInfo{}
	//err = json.Unmarshal([]byte(result.(string)), &grabInfo) // ok, but uid unmarshal fail
	//err = json.Unmarshal([]byte(gcast.ToString(result)), &grabInfo) // ok, but uid unmarshal fail
	if err = grabInfo.UnmarshalJSON([]byte(gcast.ToString(result))); err != nil { // ok, uid unmarshal ok
		logrus.Errorf("unmarsal error:%v", err)
	}

	f, err := strconv.ParseFloat(grabInfo.Amount, 64)
	if err != nil {
		logrus.Errorf("parse float error:%v", err)
	}
	logrus.Infof("User has successfully grabbed an envelope. "+
		"The result will be a JSON string: %v."+
		"grab info:%v, "+
		"amount:%.2f, "+
		"compare:%.2f\n",
		result,
		grabInfo,
		f,                                // ok
		gcast.ToFloat64(grabInfo.Amount)) // ok

}

func TestModeGrabMaster(t *testing.T) {
	name := ginfos.FuncName()
	exec := "gl:" + ginfos.Runtime.Exec() // global lock:progress name:name
	if len(name) > 0 {
		exec += ":" + name
	}

	result, err := testDistributeLock.Run(context.Background(), rwRedisClient, []string{exec}, ginfos.Runtime.IP(), gtime.IMinute).Result()
	if err != nil {
		logrus.Errorf("grab lock|err:%v", err)
		return
	}

	const (
		resultFail    = 0 // fail to grab lock
		resultSuccess = 1 // success to grab lock
		resultRenewal = 2 // renewal success
	)

	switch gcast.ToInt(result) {
	case resultFail:
		logrus.Warningf("grab lock fail")

	case resultSuccess:
		logrus.Infof("grab lock success|%v", exec)

	case resultRenewal:
		logrus.Infof("renewal success")
	}

}

type MicPositionInfo struct {
	RoomID      int64 `json:"room_id"`
	UID         int64 `json:"uid"`
	MicPosition int64 `json:"microphone_position"`
	Version     int64 `json:"version"`
}

func TestRedisMvcc(t *testing.T) {
	liveKey := "live:1633685538140921856"
	liveMicPosInfo := "mic_pos"
	micPosInfo := &MicPositionInfo{}
	// get cur version, todo use lua to get
	if res, err := rwRedisClient.HGet(context.Background(), liveKey, liveMicPosInfo).Result(); err != nil {
		logrus.Errorf("hget error, %v", err)
	} else {
		err = json.Unmarshal([]byte(gcast.ToString(res)), &micPosInfo)
		if err != nil {
			logrus.Errorf("unmarshal error, %v", err)
		}
	}
	// update some info
	micPosInfo.RoomID = algorithms.Snowflake.NextOptStreamID()
	micPosInfo.MicPosition = int64(1) + rand.Int63()%9
	logrus.Infof("info:%v", micPosInfo)

	micPosInfoJSON, err := json.Marshal(micPosInfo)
	if err != nil {
		logrus.Errorf("marshal error")
	}

	time.Sleep(5 * time.Second) // if other function to update the version, if will fail

	result, err := testMvccScript.Run(context.Background(), rwRedisClient, []string{liveKey},
		liveMicPosInfo, micPosInfo.Version, string(micPosInfoJSON)).Result()
	if err == redis.Nil {
		logrus.Infof("update nil, ok")
		return
	}
	if err != nil {
		logrus.Errorf("update error:%v", err)
		return
	}
	success := gcast.ToInt(result)
	switch success {
	case 1:
		logrus.Infof("update success:%v", result)
	case 0:
		logrus.Infof("update fail:%v", result)
	}
}

// To ensure that the Redis script is always interrupted after a certain period of time,
// even if it has not completed execution, you can use a combination of Goroutines and channels to achieve this.
func TestScriptOvertime001(t *testing.T) {
	done := make(chan error)
	go func() {
		// The TIME command argument is used to set a 10-second timeout for the script, which overrides the default lua-time-limit parameter of 5 seconds.
		// Note that the TIME argument must be followed by the timeout value in milliseconds.
		_, err := redis.NewScript(`
-- if the redis command was executed successfully, script kill is no use, you should use shutdown nosave
-- redis.call('set','age','28') -- You can only forcibly interrupt the lua script by executing the shutdown nosave command, 
							 -- because the persistence of redis will not be triggered after adding nosave
while (true)
do 
end
`).Run(context.Background(), rwRedisClient, []string{"TIME", "6000"}).Result()
		done <- err
	}()

	// Wait for a specified time, then send SHUTDOWN NOSAVE command
	/*
		If you need to wait for a specific duration before performing an action, use time.After().
		If you need to perform an action repeatedly at a fixed interval, use time.Tick() with a `for` and a `select`.
			it returns a channel that sends a value at each interval.
	*/
	select {
	case err := <-done:
		if err != nil {
			logrus.Errorf("Error executing Redis script:%v", err)
		}
	case <-time.After(5 * time.Second):
		//_, err := rwRedisClient.Do(context.Background(), "SHUTDOWN", "NOSAVE").Result()
		_, err := rwRedisClient.Do(context.Background(), "SCRIPT", "KILL").Result()
		if err != nil {
			if strings.Contains(err.Error(), "BUSY Redis is busy running a script") {
				time.Sleep(100 * time.Millisecond) // Wait for script to finish executing
			}
			logrus.Errorf("Error executing SHUTDOWN NOSAVE command:%v", err)
		} else {
			logrus.Errorf("Redis shutdown successful")
		}
	}

}
